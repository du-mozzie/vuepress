(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{590:function(_,v,l){"use strict";l.r(v);var t=l(5),o=Object(t.a)({},(function(){var _=this,v=_.$createElement,l=_._self._c||v;return l("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[l("p",[_._v("贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解。")]),_._v(" "),l("blockquote",[l("p",[_._v("算法思路")])]),_._v(" "),l("p",[_._v("贪心算法一般按如下步骤进行：")]),_._v(" "),l("ol",[l("li",[l("p",[_._v("建立数学模型来描述问题。")])]),_._v(" "),l("li",[l("p",[_._v("把求解的问题分成若干个子问题。")])]),_._v(" "),l("li",[l("p",[_._v("对每个子问题求解，得到子问题的局部最优解。")])]),_._v(" "),l("li",[l("p",[_._v("把子问题的解局部最优解合成原来解问题的一个解。")]),_._v(" "),l("p",[_._v("贪心算法是一种对某些求最优解问题的更简单、更迅速的设计技术。贪心算法的特点是一步一步地进行，常以当前情况为基础根据某个优化测度作最优选择，而不考虑各种可能的整体情况，省去了为找最优解要穷尽所有可能而必须耗费的大量时间。贪心算法采用自顶向下，以迭代的方法做出相继的贪心选择，每做一次贪心选择，就将所求问题简化为一个规模更小的子问题，通过每一步贪心选择，可得到问题的一个最优解。虽然每一步上都要保证能获得局部最优解，但由此产生的全局解有时不一定是最优的，所以贪心算法不要回溯。")])])]),_._v(" "),l("blockquote",[l("p",[_._v("算法特性")])]),_._v(" "),l("p",[_._v("贪心算法可解决的问题通常大部分都有如下的特性：")]),_._v(" "),l("ol",[l("li",[_._v("有一个以最优方式来解决的问题。为了构造问题的解决方案，有一个候选的对象的集合：比如不同面值的硬币。")]),_._v(" "),l("li",[_._v("随着算法的进行，将积累起其他两个集合：一个包含已经被考虑过并被选出的候选对象，另一个包含已经被考虑过但被丢弃的候选对象。")]),_._v(" "),l("li",[_._v("有一个函数来检查一个候选对象的集合是否提供了问题的解答。该函数不考虑此时的解决方法是否最优。")]),_._v(" "),l("li",[_._v("还有一个函数检查是否一个候选对象的集合是可行的，即是否可能往该集合上添加更多的候选对象以获得一个解。和上一个函数一样，此时不考虑解决方法的最优性。")]),_._v(" "),l("li",[_._v("选择函数可以指出哪一个剩余的候选对象最有希望构成问题的解。")]),_._v(" "),l("li",[_._v("最后，目标函数给出解的值。")])]),_._v(" "),l("blockquote",[l("p",[_._v("使用条件")])]),_._v(" "),l("p",[_._v("利用贪心法求解的问题应具备如下2个特征。")]),_._v(" "),l("p",[l("strong",[_._v("1、贪心选择性质")]),_._v("\n一个问题的整体最优解可通过一系列局部的最优解的选择达到，并且每次的选择可以依赖以前作出的选择，但不依赖于后面要作出的选择。这就是贪心选择性质。对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每一步所作的贪心选择最终导致问题的整体最优解。")]),_._v(" "),l("p",[l("strong",[_._v("2、最优子结构性质")])]),_._v(" "),l("p",[_._v("当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题可用贪心法求解的关键所在。在实际应用中，至于什么问题具有什么样的贪心选择性质是不确定的，需要具体问题具体分析。")]),_._v(" "),l("blockquote",[l("p",[_._v("解题策略")])]),_._v(" "),l("p",[_._v("贪心算法不从整体最优上加以考虑，所做出的仅是在某种意义上的局部最优选择。使用贪心策略要注意局部最优与全局最优的关系，选择当前的局部最优并不一定能推导出问题的全局最优。贪心策略解题需要解决以下两个问题；")]),_._v(" "),l("ol",[l("li",[l("p",[_._v("该问题是否适合使用贪心策略求解，也就是该问题是否具有贪心选择性质；")])]),_._v(" "),l("li",[l("p",[_._v("制定贪心策略，以达到问题的最优解或较优解。")]),_._v(" "),l("p",[_._v("要确定一个问题是否适合用贪心算法求解，必须证明每一步所作的贪心选择最终导致问题的整体最优解。证明的大致过程为：首先考察问题的一个整体最优解，并证明可修改这个最优解，使其以贪心选择开始，做了贪心选择后，原问题简化为规模更小的类似子问题。然后用"),l("a",{attrs:{href:"https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95/5155524",target:"_blank",rel:"noopener noreferrer"}},[_._v("数学归纳法"),l("OutboundLink")],1),_._v("证明通过每一步做贪心选择，最终可得到问题的整体最优解。")])])]),_._v(" "),l("blockquote",[l("p",[_._v("存在问题")])]),_._v(" "),l("p",[_._v("贪心算法也存在如下问题：")]),_._v(" "),l("ol",[l("li",[_._v("不能保证解是最佳的。因为贪心算法总是从局部出发，并没从整体考虑；")]),_._v(" "),l("li",[_._v("贪心算法一般用来解决求最大或最小解；")]),_._v(" "),l("li",[_._v("贪心算法只能确定某些问题的可行性范围。")])]),_._v(" "),l("blockquote",[l("p",[_._v("应用实例")])]),_._v(" "),l("p",[_._v("例如，平时购物找零钱时，为使找回的零钱的硬币数最少，不要求找零钱的所有方案，而是从最大面值的币种开始，按递减的顺序考虑各面额，先尽量用大面值的面额，当不足大面值时才去考虑下一个较小面值，这就是贪心算法")])])}),[],!1,null,null,null);v.default=o.exports}}]);